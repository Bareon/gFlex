from __future__ import division # No automatic floor division
from base import *
from scipy.sparse import dia_matrix, csr_matrix
from scipy.sparse.linalg import spsolve

class F1D(Flexure):
  def initialize(self, filename):
    super(F1D, self).initialize(filename)
    if debug: print 'F1D initialized'

  def run(self):
    if self.method == 'FD':
      # Finite difference
      super(F1D, self).FD()
      self.method_func = self.FD
    elif self.method == 'FFT':
      # Fast Fourier transform
      super(F1D, self).FFT()
      self.method_func = self.FFT
    elif self.method == "SPA":
      # Superposition of analytical solutions
      super(F1D, self).SPA()
      self.method_func = self.SPA
    elif self.method == "SPA_NG":
      # Superposition of analytical solutions,
      # nonuniform points
      super(F1D, self).SPA_NG()
      self.method_func = self.SPA_NG
    else:
      print 'Error: method must be "FD", "FFT", or "SPA"'
      self.abort()

    if debug: print 'F1D run'
    self.method_func ()
    # self.plot() # in here temporarily

  def finalize(self):
    ### need work
    if debug: print 'F1D finalized'
    super(F1D, self).finalize()   
    
  ########################################
  ## FUNCTIONS FOR EACH SOLUTION METHOD ##
  ########################################
  
  def FD(self):
    #try:
    #  self.plotChoice
    #except:
    #  self.plotChoice = None
    if self.plotChoice:
      self.gridded_x()
    # Only generate coefficient matrix if it is not already provided
    try:
      self.coeff
    except:
      self.elasprep() # define dx4 and D within self
      self.coeff_matrix_creator() # And define self.coeff
    self.direct_fd_solve() # Get the deflection, "w"

  def FFT(self):
    if self.plotChoice:
      self.gridded_x()
    print "The fast Fourier transform solution method is not yet implemented."
    sys.exit()
    
  def SPA(self):
    self.gridded_x()
    self.spatialDomainVars()
    self.spatialDomainGridded()

  def SPA_NG(self):
    self.spatialDomainVars()
    self.spatialDomainNoGrid()

  
  ######################################
  ## FUNCTIONS TO SOLVE THE EQUATIONS ##
  ######################################


  ## UTILITY
  ############

  def gridded_x(self):
    self.nx = self.q0.shape[0]
    self.x = np.arange(0,self.dx*self.nx,self.dx)
    
  
  ## SPATIAL DOMAIN SUPERPOSITION OF ANALYTICAL SOLUTIONS
  #########################################################

  # SETUP

  def spatialDomainVars(self):
    self.D = self.E*self.Te**3/(12*(1-self.nu**2)) # Flexural rigidity
    self.alpha = (4*self.D/(self.drho*self.g))**.25 # 1D flexural parameter
    self.coeff = self.alpha**3/(8*self.D)


  # GRIDDED

  def spatialDomainGridded(self):
  
    self.w = np.zeros(self.nx) # Deflection array
    
    for i in range(self.nx):
      # Loop over locations that have loads, and sum
      if self.q0[i]:
        dist = abs(self.x[i]-self.x)
        # -= b/c pos load leads to neg (downward) deflection
        self.w -= self.q0[i] * self.coeff * self.dx * np.exp(-dist/self.alpha) * \
          (np.cos(dist/self.alpha) + np.sin(dist/self.alpha))
    # No need to return: w already belongs to "self"
    

  # NO GRID

  def spatialDomainNoGrid(self):
  
    # Reassign q0 for consistency
    #self.q0_with_locs = self.q0 # nah, will recombine later
    self.x = self.q0[:,0]
    self.q0 = self.q0[:,1]
    
    self.w = np.zeros(self.x.shape)
    print self.w.shape
    
    i=0 # counter
    for x0 in self.x:
      dist = abs(self.x-x0)
      self.w -= self.q0[i] * self.coeff * self.dx * np.exp(-dist/self.alpha) * \
        (np.cos(dist/self.alpha) + np.sin(dist/self.alpha))
      if i==10:
        print dist
        print self.q0
      i+=1 # counter

  ## FINITE DIFFERENCE
  ######################
  
  def elasprep(self):
    """
    dx4, D = elasprep(dx,Te,E=1E11,nu=0.25)
    
    Defines the variables (except for the subset flexural rigidity) that are
    needed to run "coeff_matrix_1d"
    """
    self.dx4 = self.dx**4
    self.D = self.E*self.Te**3/(12*(1-self.nu**2))

  def coeff_matrix_creator(self):
    """
    coeff = coeff_matrix(D,drho,dx4,nu,g)
    where D is the flexural rigidity, nu is Poisson's ratio, drho is the  
    density difference between the mantle and the material filling the 
    depression, g is gravitational acceleration at Earth's surface (approx. 
    9.8 m/s), and dx4 is based on the distance between grid cells (dx).
    
    All grid parameters except nu and g are generated by the function
    varprep2d, located inside this module
    
    D must be one cell larger than q0, the load array.
  
    1D pentadiagonal matrix to solve 1D flexure with variable elastic 
    thickness via a Thomas algorithm (assuming that scipy uses a Thomas 
    algorithm).
    
    Uses the thin plate assumption, as do all of the methods here.
    
    Based on and translated in part from "flexvar.m", written in 2001 by Bob
    Anderson, which in turn is based on a code written by Laura Wallace
    
    Changes here include increased vectorization of operations (for speed) 
    and the use of sparse matrices (to reduce memory usage and unnecessary 
    tracking of zeros)
    
    Another very major change is the incorporation of multiple boundary 
    condition options
    """
    
    self.coeff_start_time = time.time()
    
    # Construct sparse array

    if self.BC_W != 'NoOutsideLoads' or self.BC_E != 'NoOutsideLoads' or \
      self.BC_W != 'Mirror' or self.BC_E != 'Mirror':
      # This step is done post-padding if NoOutsideLoads or Mirror is the 
      # boundary condition
      self.build_diagonals()

    print "Boundary condition, West:", self.BC_W, type(self.BC_W)
    print "Boundary condition, East:", self.BC_E, type(self.BC_E)

    if self.BC_W != 'NoOutsideLoads' or self.BC_E != 'NoOutsideLoads' \
      or self.BC_W != 'Mirror' or self.BC_E != 'Mirror':
      # Define an approximate maximum flexural wavelength to obtain
      # required distances to pad the array    
      self.calc_max_flexural_wavelength()

    if self.BC_E == 'Periodic' and self.BC_W == 'Periodic':
      # If both boundaries are periodic, we are good to go (and self-consistent)
      self.BC_Periodic()
    elif (self.BC_E == 'Periodic' or self.BC_W == 'Periodic') \
      and (self.BC_W != 'NoOutsideLoads' and self.BC_E != 'NoOutsideLoads' \
      and self.BC_W != 'Mirror' and self.BC_E != 'Mirror'):
      # If only one boundary is periodic and the other doesn't implicitly 
      # involve a periodic boundary, this is illegal!
      sys.exit("Having the boundary opposite a periodic boundary condition\n"+
               "be fixed and not include an implicit periodic boundary\n"+
               "condition makes no physical sense.\n"+
               "Please fix the input boundary conditions. Aborting.")
    elif self.BC_W == 'NoOutsideLoads' or self.BC_E == 'NoOutsideLoads' or \
      self.BC_W == 'Mirror' or self.BC_E == 'Mirror':
      # Boundaries that require padding!
      self.BCs_that_need_padding()
    # Both Stewart and Dirichlet can be called from inside the boundary 
    # conditions that require padding, so the "elif" is for if padding 
    # cases are not used.
    elif self.BC_E == 'Dirichlet' and self.BC_W == 'Dirichlet':
      # Stewart defaults to Dirichlet for the unpicked side, so only choose 
      # this if both sides are Dirichlet
      self.BC_Dirichlet()
    elif self.BC_E == 'Sandbox' and self.BC_W == 'Sandbox':
      # Sandbox is my testing ground - only choose if both are sandbox
      self.BC_Sandbox()
    elif self.BC_E == 'Stewart1' or self.BC_W == 'Stewart1':
      self.BC_Stewart1()
    else: self.BC_NoOutsideLoads_default()

    self.coeff_matrix = dia_matrix( (self.coeffs,self.offsets), shape = (self.ncolsx,self.ncolsx) )

    self.coeff_creation_time = time.time() - self.coeff_start_time
    print 'Time to construct coefficient (operator) array [s]:', self.coeff_creation_time
  
  def build_diagonals(self):
      """
      Builds the diagonals for the coefficient array
      Pulled out because it has to be done at a different time if that array is 
      padded
      """
      if np.isscalar(self.Te):
        # Diagonals, from left to right, for all but the boundaries 
        self.l2 = 1
        self.l1 = -4
        self.c0 = 6 + (self.dx4/self.D) * self.drho*self.g
        self.r1 = -4
        self.r2 = 1
        # Make them into arrays
        self.l2 *= np.ones(self.q0.shape)
        self.l1 *= np.ones(self.q0.shape)
        self.c0 *= np.ones(self.q0.shape)
        self.r1 *= np.ones(self.q0.shape)
        self.r2 *= np.ones(self.q0.shape)
      # LOOKS WRONG! CHECK DISCRETIZATION!
      elif type(self.Te) == np.ndarray:
        # Diagonals, from left to right  
        self.l2 = self.D[:-2] / self.dx4
        self.l1 = -2 * (self.D[1:-1] + self.D[:-2]) / self.dx4
        self.c0 = ( (self.D[2:] + 4*self.D[1:-1] + self.D[:-2]) / self.dx4 ) + self.drho*self.g
        self.r1 = -2 * (self.D[1:-1] + self.D[2:]) / self.dx4
        self.r2 = self.D[2:] / self.dx4
      # Number of columns; equals number of rows too - square coeff matrix
      self.ncolsx = self.c0.shape[0]

  def scale_matrix_values(self):
    """
    Values in the solution matrix currently have a coefficient that is pulled 
    outside of the matrix. Multiply this through the matrix here.
    This is needed for the scalar Te case
    """
    # Multiply by the factors that I pulled outside of the matrix
    for item in self.l2,self.l1,self.c0,self.r1,self.r2:
      item *= self.D/self.dx4

  def BC_Periodic(self):
    """
    Periodic boundary conditions: wraparound to the other side
    """
    # Scale values if const Te; otherwise everything is the same
    if np.isscalar(self.Te):
      self.scale_matrix_values()
    self.coeffs = np.vstack((self.l1,self.l2,self.l2,self.l1,self.c0,self.r1,self.r2,self.r2,self.r1))
    self.offsets = np.array([1-self.ncolsx,2-self.ncolsx,-2,-1,0,1,2,self.ncolsx-2,self.ncolsx-1])

  def BC_Dirichlet(self):
    """
    Boundary conditions stuck at 0!
    Nothing really has to be done: boundaries stuck at 0 anyway
    Haven't figured out how to move them... or if it is possible
    I have only seen bc motion on RHS with the explicit part of 
    implicit time-stepping matrix solutions
    """
    # Scale values if const Te; otherwise everything is the same
    if np.isscalar(self.Te):
      self.scale_matrix_values()
    self.coeffs = np.vstack((self.l2,self.l1,self.c0,self.r1,self.r2))
    self.offsets = np.array([-2,-1,0,1,2])

  def BC_Sandbox(self):
    """
    This is the sandbox for testing boundary conditions.
    It is the home of Andy Wickert's failed attempt to move Dirichlet boundary 
    conditions to non-zero values... he is now convinced that this either is 
    not possible for this kind of non-time-stepping problem that lacks an 
    explicit step or that it is beyond his insight (as of 8 March 2012)
    """
    print "WARNING! This is the sandbox set of boundary conditions. It is not\n\
          meant for actual computation, but rather for developing methods.\n\
          Works only for scalar Te."
    if np.isscalar(self.Te):
      self.q0[0] = -20
      self.q0[1] = -20
      for i in 1,-1:
        self.l2[i] = 0
        self.l1[i] = 0
        self.c0[i] = 1
        self.r1[i] = 0
        self.r2[i] = 0
      for i in 2,-2:
        self.l2[i] = 0
        self.r2[i] = 0
        self.c0[i] = 1
      self.scale_matrix_values()
      # Construct sparse array
      self.coeffs = np.vstack((self.l2,self.l1,self.c0,self.r1,self.r2))
      self.offsets = np.array([-2,-1,0,1,2])
    else:
      sys.exit("Non-scalar Te; boundary conditions not valid... and these\n\
                sandbox experimental bc's are probably not valid for anything!")

  def BC_Stewart1(self, override=False):
    """
    d2w/dx2 = d3w/dx3 = 0 per Stewart and Watts (1997) on both sides
    (no moment or shear)
    This doesn't get rid of the boundary being pinned to 0, but hugely decreases 
    dependence on it.
    I should add a way to pad around these boundary conditions at some point
    
    Override=True causes both sides to experience the boundary condition 
    regardless of whether they are assgined it
    
    Leaves the other boundary as Dirichlet
    """
    if np.isscalar(self.Te):
      # SET BOUNDARY CONDITION ON WEST (LEFT) SIDE
      if self.BC_W == 'Stewart1' or override:
        i=0
        self.c0[i] = 2 + (self.dx4/self.D)
        self.r1[i] = 0
        self.r2[i] = 0
        self.l1[i] = 0
        self.l2[i] = 0
        i=1
        self.c0[i] = 8 +(self.dx4/self.D)
        self.r2[i] = 0
        self.l2[i] = 0
      # SET BOUNDARY CONDITION ON EAST (RIGHT) SIDE
      if self.BC_E == 'Stewart1' or override:
        i=-1
        self.c0[i] = 2 + (self.dx4/self.D)
        self.r1[i] = 0
        self.r2[i] = 0
        self.l1[i] = 0
        self.l2[i] = 0
        i=-2
        self.c0[i] = 8 +(self.dx4/self.D)
        self.r2[i] = 0
        self.l2[i] = 0

      self.scale_matrix_values()  
      # Construct sparse array
      self.coeffs = np.vstack((self.l2,self.l1,self.c0,self.r1,self.r2))
      self.offsets = np.array([-2,-1,0,1,2])
    else:
      sys.exit("There are no plans to incorporate the Stewart and Watts\n\
                (1997) no-moment no-shear (d2w/dx2 = d3w/dx3 = 0)\n\
                boundary conditions for the variable elastic thickness case.")

  def BCs_that_need_padding(self):
    """
    This function acts as a main interface for BC_Mirror and BC_NoOutsideLoads.
    
    It is needed because these functions pad the array, and if one pads it on 
    one side and the other pads it on the other, the final array isn't known 
    until both boundary conditions are evaluated. Because these padding 
    boundary conditions are evaluated outside of the static boundary b.c.'s, 
    it is necessary to have them combined here (instead of above)
    """

    # self.q0 not touched until later; the two functions called from this 
    # one modify self.q0pad
    self.q0pad = self.q0.copy() # Prep for concatenation

    #from matplotlib.pyplot import plot, show, figure
    #figure(2), plot(self.q0pad)

    # Build the proper boundary conditions
    if self.BC_W == 'NoOutsideLoads' or self.BC_E == 'NoOutsideLoads':
      print "NO OUTSIDE LOADS!"
      self.BC_NoOutsideLoads()
    if self.BC_W == 'Mirror' or self.BC_E == 'Mirror':
      print "MIRROR!"
      self.BC_Mirror()
    # Pad Te, if it is an array, to match q0
    self.pad_Te()

    #figure(1), plot(self.q0pad)
    #show()

    # Finally, we build the diagonal matrix and set its boundary conditions
    self.padded_edges_BCs()

  def BC_NoOutsideLoads_default(self):
    """
    This function calls NoOutsideLoads at both edges as a default boundary 
    condition if the provided boundary condition is not understood.
    """
    
    print "Boundary condition selection not recognized:\n\
           Defaulting to NoOutsideLoads: padding + periodic boundary\n\
           conditions to one flexural wavelength outside the box.\n\
           This means that anything outside of the box or being wrapped\n\
           around has only a 0.2% effect on the rest of the system.\n\
           Flexural wavelength calculated for maximum elastic thickness."      
    self.BC_E = 'NoOutsideLoads'
    self.BC_W = 'NoOutsideLoads'

    self.q0pad = self.q0.copy() # Prep for concatenation

    self.BC_NoOutsideLoads()
    
    # Finally, we build the diagonal matrix and set its boundary conditions
    self.padded_edges_BCs()

  def BC_Mirror(self):
    """
    Mirrors q0 across the boundary on either the west (left) or east (right) 
    side, depending on the selections.
    
    This can, for example, produce a scenario in which you are observing 
    a mountain range up to the range crest (or, more correctly, the halfway 
    point across the mountain range).
    
    The mirror is run out to one flexural wavelength away from the main 
    part of the grid, after which it is clipped (if longer) or padded with 
    additional zeros (if not).
    
    This has similar rules to the no outside loads condition: if both sides 
    are mirrored, one will be mirrored and a periodic boundary condition will 
    be applied.
    """

    # Before starting, make sure that other side isn't "periodic": in that 
    # case, change it to Mirror because the solution is OFTEN the same and 
    # changing it should improve flow control (right-side padding desired 
    # in this case even if the right boundary was periodic)
    # Often but not always b/c if the domain is too short, it won't see its 
    # loads more than once with mirror, which goes against periodic (i.e. 
    # my numerical mirror doesn't work recursively like a real one would)
    if self.BC_E == 'Periodic' or self.BC_W == 'Periodic':
      print "Setting one periodic boundary in conjunction with one Mirror"
      print "boundary is OFTEN but not ALWAYS the same as setting both sides"
      print "to have no outside loads; this is because a periodic boundary"
      print "condition is often used to halve the distance that needs to be"
      print "padded."
      print "DEFAULTING TO BOTH MIRROR BOUNDARIES IN THIS SITUATION!"
      # One is already Mirror, so change both to make sure that we 
      # get both of them
      self.BC_E = 'Mirror'
      self.BC_W = 'Mirror'
    
    # First, see how far to pad: 1 flexural wavelength
    # Now this is done outside this function
    
    # Second, create the mirrored load grid
    self.q0_mirror = self.q0[::-1]
    #from matplotlib.pyplot import plot, figure
    #figure(4), plot(self.q0_mirror)
    
    # Third, make padding array (if needed)
    # If doing both sides, just repeat whole grid (if > flexural wavelength 
    # and more efficient than just repeating part of it on both sides)
    if len(self.q0_mirror) < self.maxFlexuralWavelength_ncells:
      zeropad = np.zeros(self.maxFlexuralWavelength_ncells - len(self.q0_mirror))

    # and self.BC_E = 'Mirror' or self.BC_W = 'Mirror':

    # Fourth, find what may need to be added to each side
    if self.BC_E == 'Mirror':
      if len(self.q0_mirror) < self.maxFlexuralWavelength_ncells:
        self.q0_mirror_E = np.concatenate((self.q0_mirror,zeropad))
      elif len(self.q0_mirror) >= self.maxFlexuralWavelength_ncells:
        self.q0_mirror_E = self.q0_mirror[:self.maxFlexuralWavelength_ncells]
    if self.BC_W == 'Mirror':
      if len(self.q0_mirror) < self.maxFlexuralWavelength_ncells:
        self.q0_mirror_W = np.concatenate((zeropad,self.q0_mirror))
      elif len(self.q0_mirror) > self.maxFlexuralWavelength_ncells:
        self.q0_mirror_W = self.q0_mirror[-self.maxFlexuralWavelength_ncells:]

    # Fifth, add things properly to each side
    # Starting with both sides being mirror bc's
    if self.BC_E == 'Mirror' and self.BC_W == 'Mirror':
      # Case 1: glom onto both sides because it is too short or too long
      if len(self.q0_mirror) < self.maxFlexuralWavelength_ncells \
        or len(self.q0_mirror) > 2*self.maxFlexuralWavelength_ncells:
        self.q0pad = np.concatenate((self.q0_mirror_W,self.q0pad,self.q0_mirror_E))
      # Case 2: Add to one side and later use a periodic boundary condition  
      # because it is just right and these are more efficient
      else:
        self.q0pad = np.concatenate((self.q0pad,self.q0_mirror))        
    # And then if just one side or the other is mirror:
    elif self.BC_E == 'Mirror':
      self.q0pad = np.concatenate((self.q0pad,self.q0_mirror_E))
    elif self.BC_W == 'Mirror':
      self.q0pad = np.concatenate((self.q0_mirror_W,self.q0pad))

  def BC_NoOutsideLoads(self):
    """
    Uses padding and (if needed) periodic boundary conditions to approximate 
    zero loads outside of the study area. The maximum effect of a load on the 
    boundary of the region is 0.2% of the effect it would have at its location. 
    This is because we pad out to one flexural wavelength (so exp(-2*pi)).
    Flexural wavelength is calculated for the maximum elastic thickness in the 
    array.

    Padding step creates an array, q0pad, that is padded to one side.
    It then is given periodic boundary conditions both sides.
    The padding extends for 1 flexural wavelength
    """

    # Before starting, make sure that other side isn't "periodic": in that 
    # case, change it to NoOutsideLoads because the solution is the same and 
    # changing it should improve flow control (right-side padding desired 
    # in this case even if the right boundary was periodic)
    if self.BC_E == 'Periodic' or self.BC_W == 'Periodic':
      print "Setting one periodic boundary in conjunction with one"
      print "NoOutsideLoads boundary is the same as setting both sides"
      print "to have no outside loads; this is because a periodic boundary"
      print "condition is used to halve the distance that needs to be padded."
      # One is already NoOutsideLoads, so change both to make sure that we 
      # get both of them
      self.BC_E = 'NoOutsideLoads'
      self.BC_W = 'NoOutsideLoads'

    # Create 1-flexural-wavelength-long array for padding
    zeropad = np.zeros(self.maxFlexuralWavelength_ncells)
          
    # Now pad the array
    if self.BC_E == 'NoOutsideLoads':
      self.q0pad = np.concatenate((self.q0pad,zeropad))
    elif self.BC_W == 'NoOutsideLoads':
      # "elif" because we need W with no E for this: otherwise 
      # periodic bc is applied
      self.q0pad = np.concatenate((zeropad,self.q0pad))
  
  def calc_max_flexural_wavelength(self):
    """
    Returns the approximate maximum flexural wavelength
    This is important when padding of the grid is required: in Flexure (this 
    code), grids are padded out to one maximum flexural wavelength, but in any 
    case, the flexural wavelength is a good characteristic distance for any 
    truncation limit
    """
    if np.isscalar(self.D):
      Dmax = self.D
    else:
      Dmax = self.D.max()
    # This is an approximation if there is fill that evolves with iterations 
    # (e.g., water), but should be good enough that this won't do much to it
    alpha = (4*Dmax/(self.drho*self.g))**.25 # 2D flexural parameter
    self.maxFlexuralWavelength = 2*np.pi*alpha
    self.maxFlexuralWavelength_ncells = int(np.ceil(self.maxFlexuralWavelength / self.dx))
    
  def pad_Te(self):
    """
    Pad elastic thickness to match padded q0 array.
    This is needed for the NoOutsideLoads and Mirror boundary conditions
    
    This function will do nothing if elastic thickness is a scalar... because 
    then it is not a grid that needs to be padded

    If elastic thickness is not a scalar and the boundary condition is
    NoOutsideLoads on both sides, just extend a linear gradient 
    from the rightmost to the leftmost values across the extended region
    to prevent discontinuities
    
    If the boundary condition is NoOutsideLoads on one side, it will pad the 
    entire outside region to that side with the Te that is found on that 
    edge of the array.
    
    Mirror boundary conditions mirror the elastic thickness array out to the 
    desired distance
    
    Use linspace to keep value constant on both sides of the padding seam
    And also update D based on the extended Te array

    It will also do nothing if the boundary conditions are not NoOutsideLoads
    or Mirror
    """

    if type(self.Te) == np.ndarray:
      self.Te_orig = self.Te.copy() # Save original Te
      # Get elastic thicknesses on margins for NoOutsideLoads b.c.
      if self.BC_W == 'NoOutsideLoads' or self.BC_E == 'NoOutsideLoads':
        TeW = self.Te[0]
        TeE = self.Te[-1]
        print 'Te', self.Te.shape
      # Combo #1
      if self.BC_W == 'Mirror' and self.BC_E == 'NoOutsideLoads':
        if len(self.Te_orig) < self.maxFlexuralWavelength_ncells:
          extrapad = np.ones( self.maxFlexuralWavelength_ncells - len(self.Te_orig) )
          padTeW = np.concatenate(( self.Te_orig[::-1][-1] * extrapad, self.Te_orig[::-1] ))
        else:
          padTeW = self.Te_orig[::-1][-self.maxFlexuralWavelength_ncells:]
        padTeE = np.linspace(TeE,TeW,self.maxFlexuralWavelength_ncells)
        self.Te = np.concatenate((padTeW,self.Te,padTeE))
      # Combo #2
        print 'Te NOL E', self.Te.shape
      elif self.BC_W == 'NoOutsideLoads' and self.BC_E == 'Mirror':
        padTeW = np.linspace(TeE,TeW,self.maxFlexuralWavelength_ncells)
        if len(self.Te_orig) < self.maxFlexuralWavelength_ncells:
          extrapad = np.ones( self.maxFlexuralWavelength_ncells - len(self.Te_orig) )
          padTeE = np.concatenate(( self.Te_orig[::-1], self.Te_orig[::-1][-1] * extrapad ))
        else:
          padTeE = self.Te_orig[::-1][:self.maxFlexuralWavelength_ncells]
        self.Te = np.concatenate((padTeW,self.Te,padTeE))
        print 'Te NOL W', self.Te.shape
      # Just NoOutsideLoads
      # This is the wraparound: array extended to the East
      elif self.BC_W == 'NoOutsideLoads' or self.BC_E == 'NoOutsideLoads':
        if self.BC_E == 'NoOutsideLoads':
          padTeE = np.linspace(TeE,TeW,self.maxFlexuralWavelength_ncells)
          self.Te = np.concatenate((self.Te,padTeE))
        elif self.BC_W == 'NoOutsideLoads':
          # "elif" because we need W with no E for this: otherwise 
          # periodic bc is applied and blanks are on right as for above
          padTeE = np.linspace(TeE,TeW,self.maxFlexuralWavelength_ncells)
          self.Te = np.concatenate((padTeW,self.Te))
      # Just Mirror
      elif self.BC_W == 'Mirror' and self.BC_E == 'Mirror':
        # Case 1: padded on both sides 
        if len(self.Te_orig) < self.maxFlexuralWavelength_ncells:
          extrapad = np.ones( self.maxFlexuralWavelength_ncells - len(self.Te_orig) )
          padTeW = np.concatenate(( self.Te_orig[::-1][-1] * extrapad, self.Te_orig[::-1] ))
          padTeE = np.concatenate(( self.Te_orig[::-1], self.Te_orig[::-1][-1] * extrapad ))
          self.Te = np.concatenate((padTeW, self.Te,padTeE))
        elif len(self.Te_orig) > 2*self.maxFlexuralWavelength_ncells:
          padTeW = self.Te_orig[::-1][-self.maxFlexuralWavelength_ncells:]
          padTeE = self.Te_orig[::-1][:self.maxFlexuralWavelength_ncells]
          self.Te = np.concatenate((padTeW, self.Te, padTeE))
        # Case 2: Padded on right
        else:
          # Can't go the whole length because Te_orig is padded
          # SO THIS IS DIFFERENT FROM THE Q0, TE MIRRORING OF THE ENDPOINT 
          # BEFORE!
          padTeE = self.Te_orig[::-1][1:-1]
          self.Te = np.concatenate((self.Te,padTeE))
      # Combo and mirror-only cases already accounted for, so can just do a 
      # simple if
      elif self.BC_W == 'Mirror':
        if len(self.Te_orig) < self.maxFlexuralWavelength_ncells:
          extrapad = np.ones( self.maxFlexuralWavelength_ncells - len(self.Te_orig) )
          padTeW = np.concatenate(( self.Te_orig[::-1][-1] * extrapad, self.Te_orig[::-1] ))
        else:
          padTeW = self.Te_orig[::-1][-self.maxFlexuralWavelength_ncells:]
        self.Te = np.concatenate((padTeW,self.Te))
      elif self.BC_E == 'Mirror':
        if len(self.Te_orig) < self.maxFlexuralWavelength_ncells:
          extrapad = np.ones( self.maxFlexuralWavelength_ncells - len(self.Te_orig) )
          padTeE = np.concatenate(( self.Te_orig[::-1], self.Te_orig[::-1][-1] * extrapad ))
        else:
          padTeE = self.Te_orig[::-1][:self.maxFlexuralWavelength_ncells]
        self.Te = np.concatenate((self.Te,padTeE))
      # Update D
      self.D = self.E*self.Te**3/(12*(1-self.nu**2)) # Flexural rigidity
  
  def padded_edges_BCs(self):
    """
    Sets the boundary conditions outside of padded edges; this is important 
    for the NoOutsideLoads and Mirror boundary conditions

    Also makes an archival copy of q0 for while q0 is temporarily replaced 
    by the padded version of it
    """

    # Need to hold on to q0 array to keep its size; self.q0 will be redefined 
    # for the computation
    self.q0_orig = self.q0.copy()
    print 'q0_orig',len(self.q0_orig)
    
    # Then copy over q0
    self.q0 = self.q0pad.copy()
        
    # First, we have to build the diagonal matrix, which wasn't pre-done 
    # for us because we've just changed its size.
    self.build_diagonals()

    # Now we are all ready to throw this in the periodic boundary condition
    # matrix builder, if needed!
    if self.BC_E == 'NoOutsideLoads' and self.BC_W == 'NoOutsideLoads':
      self.BC_Periodic()
    elif self.BC_E == 'Mirror' and self.BC_W == 'Mirror':
      # Case 1: glommed onto both sides because it is too short or too long
      # (Should have this be a maxFlexuralWavelength class variable, but
      # just recalculating for now)
      if len(self.q0_mirror) < self.maxFlexuralWavelength_ncells \
        or len(self.q0_mirror) > 2*self.maxFlexuralWavelength_ncells:
        if np.isscalar(self.Te):
          # Implemented only for constant Te, but produces less of a 
          # boundary effect on the solution
          self.BC_Stewart1(override = True)
        else:
          self.BC_Dirichlet()
      # Case 2: Adedd to one side and now use a periodic boundary condition 
      # because the array length is just right and these are more efficient
      else:
        self.BC_Periodic()
    # Mixed case
    elif self.BC_W == 'NoOutsideLoads' and self.BC_E == 'Mirror' or \
      self.BC_W == 'Mirror' and self.BC_E == 'NoOutsideLoads':
      if np.isscalar(self.Te):
        # Implemented only for constant Te, but produces less of a 
        # boundary effect on the solution
        self.BC_Stewart1(override = True)
      else:
        self.BC_Dirichlet()
    else:
      # Apply other BC to both sides: one is padded so it won't matter, and 
      # the other one is where it counts
      if self.BC_E == 'Stewart1' or self.BC_W == 'Stewart1':
        self.BC_Stewart1(override = True)
      elif self.BC_E == 'Dirichlet' or self.BC_W == 'Dirichlet':
        # Would be better to use Stewart1 on padded side if possible, but not 
        # going to becasue it is implemented only for the constant Te case
        self.BC_Dirichlet()
      else: sys.exit("If only one side is padded and the other isn't, valid boundary\n"+
                     "condition options are 'Stewart1' and 'Dirichlet'. Aborting.")

  def direct_fd_solve(self):
    """
    w = direct_fd_solve()
      where coeff is the sparse coefficient matrix output from function
      coeff_matrix and q0 is the array of loads

    Sparse solver for one-dimensional flexure of an elastic plate
    """
    
    #print 'q0', self.q0.shape
    #print 'Te', self.Te.shape
    print 'maxFlexuralWavelength_ncells', self.maxFlexuralWavelength_ncells
    
    self.solver_start_time = time.time()
    
    coeff_matrix = csr_matrix(self.coeff_matrix) # Needed for solution
    q0sparse = csr_matrix(-self.q0) # Negative so bending down with positive load,
                                    # bending up with negative load (i.e. material
                                    # removed)
                                    # *self.dx
    # UMFpack is now the default, but setting true just to be sure in case
    # anything changes
    self.w = spsolve(coeff_matrix,q0sparse,use_umfpack=True)
    
    self.time_to_solve = time.time() - self.solver_start_time
    print 'Time to solve [s]:', self.time_to_solve
    
    # If needed, revert q0 and Te to original dimensions
    self.back_to_original_q0_Te_w()
    
    #print self.w.shape
    
    #print self.w
    
  def back_to_original_q0_Te_w(self):
    """
    Pull out the parts of q0, Te that we want for special boundary condition
    cases
    """
    #print self.w.shape
    #print self.BC_W
    #print self.BC_E
    #from matplotlib.pyplot import plot,show,figure
    #figure(1),plot(self.q0), show()
    #figure(2),plot(self.w), show()
    #figure(5), plot(self.Te), show()
    #print self.maxFlexuralWavelength_ncells
    # Special case: clipping needed for the NoOutsideLoads boundary condition.
    # This clipping also works for most of the Mirror boundary conditions
    if self.BC_W == 'NoOutsideLoads' or self.BC_E == 'NoOutsideLoads' or \
      self.BC_W == 'Mirror' or self.BC_E == 'Mirror':
      self.q0 = self.q0_orig
      if type(self.Te) == np.ndarray:
        self.Te = self.Te_orig
    # Combo!
    if self.BC_W == 'NoOutsideLoads' and self.BC_E == 'Mirror' or \
      self.BC_W == 'Mirror' and self.BC_E == 'NoOutsideLoads':
      # Mixed - padded on both sides
      self.w = self.w[self.maxFlexuralWavelength_ncells:-self.maxFlexuralWavelength_ncells]
    # Just NoOutsideLoads
    elif self.BC_W == 'NoOutsideLoads' or self.BC_E == 'NoOutsideLoads':
      if self.BC_E == 'NoOutsideLoads':
        self.w = self.w[:len(self.q0_orig)]
      elif self.BC_W == 'NoOutsideLoads':
        # "elif" because we need W with no E for this: otherwise 
        # periodic bc is applied and blanks are on right as for above
        self.w = self.w[-len(self.q0_orig):]
    # Just Mirror
    elif self.BC_E == 'Mirror' and self.BC_W == 'Mirror':
      # Case 1: padded on both sides 
      if len(self.q0_mirror) < self.maxFlexuralWavelength_ncells \
        or len(self.q0_mirror) > 2*self.maxFlexuralWavelength_ncells:
        print self.w.shape
        self.w = self.w[self.maxFlexuralWavelength_ncells:-self.maxFlexuralWavelength_ncells]
      # Case 2: Padded on right
      else:
        self.w = self.w[:len(self.q0_orig)]
    # Combo and mirror-only cases already accounted for, so can just do a 
    # simple if
    elif self.BC_W == 'Mirror':
      self.w = self.w[self.maxFlexuralWavelength_ncells:]
    elif self.BC_E == 'Mirror':
      self.w = self.w[:-self.maxFlexuralWavelength_ncells]

