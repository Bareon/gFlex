from __future__ import division # No automatic floor division
from base import *


class F1D(Flexure):
  def initialize(self, filename):
    super(F1D, self).initialize(filename)
    if debug: print 'F1D initialized'

  def run(self):
    if self.method == 'FD':
      # Finite difference
      super(F1D, self).FD()
      self.method_func = self.FD
    elif self.method == 'FFT':
      # Fast Fourier transform
      super(F1D, self).FFT()
      self.method_func = self.FFT
    elif self.method == "SPA":
      # Superposition of analytical solutions
      super(F1D, self).SPA()
      self.method_func = self.SPA
    elif self.method == "SPA_NG":
      # Superposition of analytical solutions,
      # nonuniform points
      super(F1D, self).SPA_NG()
      self.method_func = self.SPA_NG
    else:
      print 'Error: method must be "FD", "FFT", or "SPA"'
      self.abort()

    if debug: print 'F1D run'
    self.method_func ()
    # self.plot() # in here temporarily

  def finalize(self):
    ### need work
    if debug: print 'F1D finalized'
    super(F1D, self).finalize()   
    
  ########################################
  ## FUNCTIONS FOR EACH SOLUTION METHOD ##
  ########################################
  
  def FD(self):
    if self.plotChoice:
      self.gridded_x()
    # Only generate coefficient matrix if it is not already provided
    try:
      self.coeff
    except:
      dx4, D = self.elasprep(self.dx,self.Te,self.E,self.nu)
      print "***",
      print type(self.Te),
      #print self.Te.shape
      print "***"
      if type(self.Te) is np.ndarray:
        self.coeff = self.coeff_matrix(D,self.drho,dx4,self.nu,self.g)
      elif np.isscalar(self.Te):
        print "***SCALAR!!!***"
        self.coeff = self.coeff_matrix_const_te(D,self.drho,dx4,self.nu,self.g)
      else:
        print "Unsupported coefficient matrix input type."
        print "Please use a scalar or numpy array (numpy.ndarray) type"
        print "Exiting."
        sys.exit()
    self.w = self.direct_fd_solve(self.coeff,self.q0)

  def FFT(self):
    if self.plotChoice:
      self.gridded_x()
    print "The fast Fourier transform solution method is not yet implemented."
    sys.exit()
    
  def SPA(self):
    self.gridded_x()
    self.spatialDomainVars()
    self.spatialDomainGridded()

  def SPA_NG(self):
    self.spatialDomainVars()
    self.spatialDomainNoGrid()

  
  ######################################
  ## FUNCTIONS TO SOLVE THE EQUATIONS ##
  ######################################


  ## UTILITY
  ############

  def gridded_x(self):
    from numpy import arange
    self.nx = self.q0.shape[0]
    self.x = arange(0,self.dx*self.nx,self.dx)
    
  
  ## SPATIAL DOMAIN SUPERPOSITION OF ANALYTICAL SOLUTIONS
  #########################################################

  # SETUP

  def spatialDomainVars(self):
    self.D = self.E*self.Te**3/(12*(1-self.nu**2)) # Flexural rigidity
    self.alpha = (4*self.D/(self.drho*self.g))**.25 # 1D flexural parameter
    self.coeff = self.alpha**3/(8*self.D)


  # GRIDDED

  def spatialDomainGridded(self):
  
    from numpy import zeros, exp, sin, cos

    self.w = zeros(self.nx) # Deflection array
    
    for i in range(self.nx):
      # Loop over locations that have loads, and sum
      if self.q0[i]:
        dist = abs(self.x[i]-self.x)
        # -= b/c pos load leads to neg (downward) deflection
        self.w -= self.q0[i] * self.coeff * self.dx * exp(-dist/self.alpha) * \
          (cos(dist/self.alpha) + sin(dist/self.alpha))
    # No need to return: w already belongs to "self"
    

  # NO GRID

  def spatialDomainNoGrid(self):
  
    from numpy import exp, sin, cos, zeros
    
    # Reassign q0 for consistency
    #self.q0_with_locs = self.q0 # nah, will recombine later
    self.x = self.q0[:,0]
    self.q0 = self.q0[:,1]
    
    self.w = zeros(self.x.shape)
    print self.w.shape
    
    i=0 # counter
    for x0 in self.x:
      dist = abs(self.x-x0)
      self.w -= self.q0[i] * self.coeff * self.dx * exp(-dist/self.alpha) * \
        (cos(dist/self.alpha) + sin(dist/self.alpha))
      if i==10:
        print dist
        print self.q0
      i+=1 # counter

  ## FINITE DIFFERENCE
  ######################
  
  def elasprep(self,dx,Te,E=1E11,nu=0.25):
    """
    dx4, D = elasprep(dx,Te,E=1E11,nu=0.25)
    
    Defines the variables (except for the subset flexural rigidity) that are
    needed to run "coeff_matrix_1d"
    """
    dx4 = dx**4
    D = E*Te**3/(12*(1-nu**2))
    output = dx4, D
    return output

  def coeff_matrix(self,D,drho,dx4,nu=0.25,g=9.8):
    """
    coeff = coeff_matrix(D,drho,dx4,nu,g)
    where D is the flexural rigidity, nu is Poisson's ratio, drho is the  
    density difference between the mantle and the material filling the 
    depression, g is gravitational acceleration at Earth's surface (approx. 
    9.8 m/s), and dx4 is based on the distance between grid cells (dx).
    
    All grid parameters except nu and g are generated by the function
    varprep2d, located inside this module
    
    D must be one cell larger than q0, the load array.
  
    1D pentadiagonal matrix to solve 1D flexure with variable elastic 
    thickness via a Thomas algorithm (assuming that scipy uses a Thomas 
    algorithm).
    
    Uses the thin plate assumption, as do all of the methods here.
    
    Based on and translated in part from "flexvar.m", written in 2001 by Bob
    Anderson, which in turn is based on a code written by Laura Wallace
    
    Changes here include increased vectorization of operations (for speed) 
    and the use of sparse matrices (to reduce memory usage and unnecessary 
    tracking of zeros)
    """
    
    from numpy import vstack, array
    from scipy.sparse import dia_matrix

    self.coeff_start_time = time.time()

    # Diagonals, from left to right  
    l2 = D[:-2] / dx4
    l1 = -2 * (D[1:-1] + D[:-2]) / dx4
    c0 = ( (D[2:] + 4*D[1:-1] + D[:-2]) / dx4 ) + drho*g
    r1 = -2 * (D[1:-1] + D[2:]) / dx4
    r2 = D[2:] / dx4
    
    ncolsx = c0.shape[0]

    # Construct sparse array

    if self.BC == 'Periodic':
      # Periodic boundary conditions
      coeffs = vstack((l1,l2,l2,l1,c0,r1,r2,r2,r1))
      offsets = array([1-ncolsx,2-ncolsx,-2,-1,0,1,2,ncolsx-2,ncolsx-1])    

    elif self.BC == 'Dirichlet':
      # "Default" 0-displacement boundary conditions
      coeffs = vstack((l2,l1,c0,r1,r2))
      offsets = array([-2,-1,0,1,2])

    else:
      sys.exit("Only Periodic and Dirichlet Boundary Conditions work\n\
                For the variable elastic thickness 1D solution.")
      if self.BC == 'Stewart1':
        pass # You did this on purpose!
      else:
        # Shouldn't be possible to even get to this message unless overall 
        # architecture is changed (or this value is set to optional)
        print "Boundary condition selection not recognized:"
        print "Defaulting to Stewart1 (no moment or shear)"
      # Now change their ends for boundary condition
      # currently d2w/dx2 = d3w/dx3 = 0 per Stewart and Watts (1997)
      # same b.c. on both sides
      for i in 0,-1:
        c0[i] = 2 + (dx4/D)
        r1[i] = 0
        r2[i] = 0
        l1[i] = 0
        l2[i] = 0
      for i in 1,-2:
        c0[i] = 8 +(dx4/D)
        r2[i] = 0
        l2[i] = 0
      # Construct sparse array: This was copy/pasted from coeff_matrix function
      coeffs = vstack((l2,l1,c0,r1,r2))
      offsets = array([-2,-1,0,1,2])


    c = dia_matrix( (coeffs,offsets), shape = (ncolsx,ncolsx) )

    print 'Time to construct coefficient (operator) array [s]:',
    print time.time() - self.coeff_start_time

    return c
    
  def coeff_matrix_const_te(self,D,drho,dx4,nu=0.25,g=9.8):
    """
    Same as above coeff_matrix except with the constant Te assumption
    Currently a sandbox to work on boundary conditions
    """
    from numpy import vstack, array
    from scipy.sparse import dia_matrix

    self.coeff_start_time = time.time()

    # Diagonals, from left to right, for all but the boundaries 
    l2 = 1
    l1 = -4
    c0 = 6 + (dx4/D) * drho*g
    r1 = -4
    r2 = 1
    # Make them into lists
    l2 *= np.ones(self.q0.shape)
    l1 *= np.ones(self.q0.shape)
    c0 *= np.ones(self.q0.shape)
    r1 *= np.ones(self.q0.shape)
    r2 *= np.ones(self.q0.shape)

    ncolsx = c0.shape[0] # nrows will be this too - square coeff matrix

    print self.BC, type(self.BC)

#    Before anything else
#    if self.BC == 'Mirror':
      # Brute force the the mirror boundary condition
      

    if self.BC == 'Periodic':
      # Periodic boundary conditions
      # Multiply by the factors that I pulled outside of the matrix
      for item in l2,l1,c0,r1,r2:
        item *= D/dx4
      coeffs = vstack((l1,l2,l2,l1,c0,r1,r2,r2,r1))
      offsets = array([1-ncolsx,2-ncolsx,-2,-1,0,1,2,ncolsx-2,ncolsx-1])

    elif self.BC == 'Dirichlet':
      # Nothing really has to be done
      # Multiply by the factors that I pulled outside of the matrix
      self.q0[0] = -20
      self.q0[1] = -20
      self.q0[2] = -20
      for item in l2,l1,c0,r1,r2:
        item *= D/dx4
      coeffs = vstack((l2,l1,c0,r1,r2))
      offsets = array([-2,-1,0,1,2])

    elif self.BC == 'global':
      print "Global boundary condition is not yet implemented"
      print "And it doesn't work for 1D anyway - just use 'Periodic'"
      sys.exit()

    elif self.BC == 'Neumann':
      # currently dw/dx = 0: applied to both +/- 1 and +/- 2
      # same b.c. on both sides
      # Could divide all of these by 2 and get the same answer (b/c 8, 2)
      # Still very rigid at boundaries and stuck at 0 -- why???
      # MAKES NO DIFFERENCE FROM DIRICHILET!!!
      for i in 0,-1:
        r1[i] = 8
        r2[i] = 2
        l1[i] = 8
        l2[i] = 2
      for i in 1,-2:
        r2[i] = 2
        l2[i] = 2
      # Multiply by the factors that I pulled outside of the matrix
      for item in l2,l1,c0,r1,r2:
        item *= D/dx4
      # Construct sparse array: This was copy/pasted from coeff_matrix function
      coeffs = vstack((l2,l1,c0,r1,r2))
      offsets = array([-2,-1,0,1,2])

    elif self.BC == 'Sandbox':
      self.q0[0] = -20
      self.q0[1] = -20
      for i in 1,-1:
        l2[i] = 0
        l1[i] = 0
        c0[i] = 1
        r1[i] = 0
        r2[i] = 0
      for i in 2,-2:
        l2[i] = 0
        r2[i] = 0
        c0[i] = 1
      # Multiply by the factors that I pulled outside of the matrix
      for item in l2,l1,c0,r1,r2:
        item *= D/dx4
      # Construct sparse array: This was copy/pasted from coeff_matrix function
      coeffs = vstack((l2,l1,c0,r1,r2))
      offsets = array([-2,-1,0,1,2])

    else:
      if self.BC == 'Stewart1':
        pass # You did this on purpose!
      else:
        # Shouldn't be possible to even get to this message unless overall 
        # architecture is changed (or this value is set to optional)
        print "Boundary condition selection not recognized:"
        print "Defaulting to Stewart1 (no moment or shear)"
      # Now change their ends for boundary condition
      # currently d2w/dx2 = d3w/dx3 = 0 per Stewart and Watts (1997)
      # same b.c. on both sides
      for i in 0,-1:
        c0[i] = 2 + (dx4/D)
        r1[i] = 0
        r2[i] = 0
        l1[i] = 0
        l2[i] = 0
      for i in 1,-2:
        c0[i] = 8 +(dx4/D)
        r2[i] = 0
        l2[i] = 0
      print c0
      print dx4
      print D
      print dx4/D
      # Multiply by the factors that I pulled outside of the matrix
      for item in l2,l1,c0,r1,r2:
        item *= D/dx4
      # Construct sparse array: This was copy/pasted from coeff_matrix function
      coeffs = vstack((l2,l1,c0,r1,r2))
      offsets = array([-2,-1,0,1,2])

    c = dia_matrix( (coeffs,offsets), shape = (ncolsx,ncolsx) )
    
    print 'Time to construct coefficient (operator) array [s]:',
    print time.time() - self.coeff_start_time
    
    return c

  def direct_fd_solve(self,coeff,q0):
    """
    w = direct_fd_solve(coeff,q0)
      where coeff is the sparse coefficient matrix output from function
      coeff_matrix and q0 is the array of loads

    Sparse solver for one-dimensional flexure of an elastic plate
    """
    
    from scipy.sparse.linalg import spsolve
    from scipy.sparse import csr_matrix

    self.solver_start_time = time.time()
    
    coeff = csr_matrix(coeff) # Needed for solution
    q0sparse = csr_matrix(-q0) # Negative so bending down with positive load,
                               # bending up with negative load (i.e. material
                               # removed)
                               # *self.dx
    w = spsolve(coeff,q0sparse)
    #print w

    print 'Time to solve [s]:',
    print time.time() - self.solver_start_time

    return w

