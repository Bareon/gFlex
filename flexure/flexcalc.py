"""
Functions for finite-difference solutions to the thin-plate flexure equation. \\
\\
Written by Andrew D. Wickert. \\
Started 1 November 2010, Preliminary version finished 6 November 2010. \\
More edits on 7, 8 Nov. 2010; changed sign of "w" (flex down w/ positive load) \\
Based on MATLAB code started in late Spring / early Summer 2010 \\
\\
Originally called fvet = "Flexure: Variable Elastic Thickness"
Planned expansion to analytical solutions required new name: "flexcalc"
"""

from __future__ import division # No floor division here

def importascii(f,d=' '):
  """
  imported_array_varname = importarray(filename,delimiter=' ') \\
  \\
  Both filename and delimiter must be strings (grep commands work, \\
  e.g., use \t as delim for tab)
  """
  from numpy import loadtxt
  imported_array = loadtxt(fname=f,delimiter=d)
  return imported_array
  
def importsparse(filename):
  """
  varname = importsparse(filename): \\
  \\
  "filename" must be an object or string
  """
  from scipy.io import mmread
#  from scipy.sparse import lil_matrix
  a = mmread(filename)
#  a = lil_matrix(a)
  return a
  
def varprep2d(dx,dy,Te,E=1E11,nu=0.25,rho_m=3300,rho_fill=0):
  """
  dx4, dy4, dx2dy2, D, drho = \
    varprep2d(dx,dy,Te,E=,nu=0.25,rho_m=3300,rho_fill=0)
  
  Defines the variables (except for the subset flexural rigidity) that are
  needed to run "coeff_matrix_2d"
  """
  dx4 = dx**4
  dy4 = dy**4
  dx2dy2 = dx**2 * dy**2
  D = E*Te**3/(12*(1-nu**2))
  drho = rho_m - rho_fill
  output = dx4, dy4, dx2dy2, D, drho
  return output

def varprep1d(dx,Te,E=1E11,nu=0.25,rho_m=3300,rho_fill=0):
  """
  dx4, D, drho = varprep1d(dx,Te,E=1E11,nu=0.25,rho_m=3300,rho_fill=0)
  
  Defines the variables (except for the subset flexural rigidity) that are
  needed to run "coeff_matrix_1d"
  """
  dx4 = dx**4
  D = E*Te**3/(12*(1-nu**2))
  drho = rho_m - rho_fill
  output = dx4, D, drho
  return output


def subset_2d(a):
  """
  NOTE: it is suggested to not use this function (as defining the load array,
  q0, often takes a lot of work and you don't want to clip that work away).
  Instead, just use an elastic thickness map that is two cells wider on each
  side than your map of loads.
  Note 2: Actually, the elastic thickness map should need only to be 1 cell
  wider on each side; this should be fixed soon.
  
  b = subset_2d(a) \\
  \\  
  Takes only the interior elements of the array (skipping first and last two). \\
  This should be used for the elastic thickness array, which should be imported \\
  as two elements wider on each edge as the load array (because the 4th-order \\
  finite difference requires this for a solution within the area of the load).
  """
  b = a[2:-2,2:-2]
  return b

def coeff_matrix_2d(D,drho,dx4,dy4,dx2dy2,nu=0.25,g=9.8):
  """
  coeff = coeff_matrix_2d(D,drho,dx4,dy4,dx2dy2,nu=0.25,g=9.8)
    where D is the flexural rigidity, drho is the density difference between
    the mantle and the material filling the depression, nu is Poisson's ratio,
    g is gravitational acceleration at Earth's surface (approx. 9.8 m/s),
    and dx4, dy4, and dx2dy2 are based on the grid dimensions.
    
    All grid parameters except nu and g are generated by the function
    varprep2d, located inside this module
  
  Calculates the matrix of coefficients that is later used via sparse matrix
  solution techniques (scipy.sparse.linalg.spsolve) to compute the flexural
  response to the load. This step need only be performed once, and the
  coefficient matrix can very rapidly compute flexural solutions to any load.
  This makes this particularly good for probelms with time-variable loads or 
  that require iteration (e.g., water loading, in which additional water causes
  subsidence, causes additional water detph, etc.).
  
  This method of coefficient matrix construction utilizes longer-range
  symmetry in the coefficient matrix to build it block-wise, as opposed to
  the much less computationally efficient row-by-row ("serial") method 
  that was previously employed and remains in fuction "coeff_matrix_2d_serial".
  
  NOTATION FOR COEFFICIENT BIULDING MATRICES (e.g., "cj0i_2"):
  c = "coefficient
  j = columns = x-value
  j0 = no offset: look at center of array
  i = rows = y-value
  i_2 = negative 2 offset (i2 = positive 2 offset)
  """
  
  import numpy as np
  from scipy import sparse

  # Build matrices containing all of the values for each of the coefficients
  # that must be linearly combined to solve this equation
  # 13 coefficients: 13 matrices of the same size as the load

  cj2i0 = (D[2:-2,2:-2] + 0.5*(D[3:-1,2:-2] - D[1:-3,2:-2]))/dy4
  cj1i_1 = (2*D[2:-2,2:-2] \
    + 0.5*(-D[2:-2,3:-1] + D[2:-2,1:-3] + D[3:-1,2:-2] - D[1:-3,2:-2]) \
    + ((1-nu)/8) * (D[3:-1,3:-1] - D[1:-3,3:-1] - D[3:-1,1:-3] \
      + D[1:-3,1:-3])) / dx2dy2
  cj1i0 = (-6*D[2:-2,2:-2] + 2*D[1:-3,2:-2])/dy4 \
    + nu*(D[2:-2,3:-1] - 2*D[2:-2,2:-2] + D[2:-2,1:-3])/dx2dy2 \
    + (-D[3:-1,2:-2] - 4*D[2:-2,2:-2] + D[1:-3,2:-2])/dx2dy2
  cj1i1 = (2*D[2:-2,2:-2] \
    + 0.5*(D[2:-2,3:-1] - D[2:-2,1:-3] + D[3:-1,2:-2] - D[1:-3,2:-2]) \
    + ((1-nu)/8)*(D[3:-1,3:-1] - D[1:-3,3:-1] - D[3:-1,1:-3] + D[1:-3,1:-3])) \
    /dx2dy2
  cj0i_2 = (D[2:-2,2:-2] - 0.5*(D[2:-2,3:-1] - D[2:-2,1:-3])) / dx4
  cj0i_1 = (2*D[2:-2,3:-1] - 6*D[2:-2,2:-2]) / dx4 \
    + nu*(D[3:-1,2:-2] - 2*D[2:-2,2:-2] + D[1:-3,2:-2]) / dx2dy2 \
    + (D[2:-2,3:-1] - 4*D[2:-2,2:-2] - D[2:-2,3:-1]) / dx2dy2
  cj0i0 = (-2*D[2:-2,3:-1] + 10*D[2:-2,2:-2] - 2*D[2:-2,1:-3]) / dx4 \
    + (-2*D[3:-1,2:-2] + 10*D[2:-2,2:-2] - 2*D[1:-3,2:-2]) / dy4 \
    + (8*D[2:-2,2:-2]) / dx2dy2 \
    + nu*(-2*D[2:-2,3:-1] - 2*D[2:-2,1:-3] + 8*D[2:-2,2:-2] \
      - 2*D[3:-1,2:-2] -2*D[1:-3,2:-2]) / dx2dy2 \
    + drho*g
  cj0i1 = (-6*D[2:-2,2:-2] + 2*D[2:-2,1:-3]) / dx4 \
    + nu*(D[3:-1,2:-2] - 2*D[2:-2,2:-2] + D[1:-3,2:-2]) / dx2dy2 \
    + (-D[2:-2,3:-1] - 4*D[2:-2,2:-2] + D[2:-2,1:-3]) / dx2dy2
  cj0i2 = (D[2:-2,2:-2] + 0.5*(D[2:-2,3:-1] - D[2:-2,1:-3])) / dx4
  cj_1i_1 = (2*D[2:-2,2:-2] \
    + 0.5*(-D[2:-2,3:-1] + D[2:-2,1:-3] - D[3:-1,2:-2] + D[1:-3,2:-2]) \
    + ((1-nu)/8)*(D[3:-1,3:-1] - D[1:-3,3:-1] - D[3:-1,1:-3] + D[1:-3,1:-3])) \
    / dx2dy2
  cj_1i0 = (2*D[3:-1,2:-2] - 6*D[2:-2,2:-2]) / dy4 \
    + nu*(D[2:-2,3:-1] - 2*D[2:-2,2:-2] + D[2:-2,1:-3]) / dx2dy2 \
    + (D[3:-1,2:-2] - 4*D[2:-2,2:-2] - D[1:-3,2:-2]) / dx2dy2
  cj_1i1 = (2*D[2:-2,2:-2] \
    + 0.5*(D[2:-2,3:-1] - D[2:-2,1:-3] - D[3:-1,2:-2] + D[1:-3,2:-2]) \
    - ((1-nu)/8) * (D[3:-1,3:-1] - D[1:-3,3:-1] - D[3:-1,1:-3] \
      + D[1:-3,1:-3])) / dx2dy2
  cj_2i0 = (D[2:-2,2:-2] - 0.5*(D[3:-1,2:-2] - D[1:-3,2:-2])) / dy4

  # ASSEMBLE COEFFICIENT MATRIX
  
  # Loop over rows, with each block being a square with both side
  # lengths being the number of columns (i.e. the number of entries 
  # in each row)
  ncolsx = cj0i0.shape[1]
  nrowsy = cj0i0.shape[0]

  # Create a block of zeros to pad the blocks with diagonals and
  # keep everything in the right place.
  # Also important because we will be concatenating these arrays
  # together and need all the sparse arrays to have the same size
  # Looks like actually more efficient if I don't use this, though 
  # it is a nicer conceptualization
  #zeroblock = sparse.dia_matrix( (ncolsx,ncolsx) );

  for i in range(nrowsy):
  
    # CREATE SPARSE n-DIAGONAL BLOCKS FROM EACH ROW OF THESE MATRICES

    # Leftmost / bottom (which is topmost compared to point about which
    # we are calculating)
    coeffs = cj2i0[i,:]
    offsets = np.array([0])
    l2 = sparse.dia_matrix( (coeffs,offsets), shape = (ncolsx,ncolsx) )

    # Mid-left
    coeffs = np.array([cj1i_1[i,:],cj1i0[i,:],cj1i1[i,:]])
    offsets = np.array([-1,0,1])
    l1 = sparse.dia_matrix( (coeffs,offsets), shape = (ncolsx,ncolsx) )
    
    # Center
    coeffs = np.array([cj0i_2[i,:],cj0i_1[i,:],cj0i0[i,:],
                       cj0i1[i,:],cj0i2[i,:]])
    offsets = np.array([-2,-1,0,1,2])
    c0 = sparse.dia_matrix( (coeffs,offsets), shape = (ncolsx,ncolsx) )
    
    # Mid-right
    coeffs = np.array([cj_1i_1[i,:],cj_1i0[i,:],cj_1i1[i,:]])
    offsets = np.array([-1,0,1])
    r1 = sparse.dia_matrix( (coeffs,offsets), shape = (ncolsx,ncolsx) )
    
    # Right
    coeffs = cj2i0[i,:]
    offsets = np.array([0])
    r2 = sparse.dia_matrix( (coeffs,offsets), shape = (ncolsx,ncolsx) )
    
    # ASSEMBLE INTO ONE ROW OF BLOCKS FOR EACH TIME-STEP
    # Adding blocks of zeros of size ncolsx to each side of the array
    # in order to pad it for later concatenation (i.e. making all same size
    # and putting nonzero blocks in correct places)
    # There has got to be a more elegant way to do this, but I don't know it
    # and it will take longer to figure out than to just write it all out now.
    
    if i>=3 and i<=nrowsy-4: # If no truncation at edges (normal case)
      leftzeros = sparse.dia_matrix((ncolsx,ncolsx*(i-2)))
      rightzeros = sparse.dia_matrix((ncolsx,ncolsx*(nrowsy-3-i)))
      coeff_row = sparse.hstack( [leftzeros,l2,l1,c0,r1,r2,rightzeros] )
    
    elif i==0:
      rightzeros = sparse.dia_matrix((ncolsx,ncolsx*(nrowsy-3-i)))
      coeff_row = sparse.hstack( [c0,r1,r2,rightzeros] )
      
    elif i==1:
      rightzeros = sparse.dia_matrix((ncolsx,ncolsx*(nrowsy-3-i)))
      coeff_row = sparse.hstack( [l1,c0,r1,r2,rightzeros] )
    
    elif i==2:
      rightzeros = sparse.dia_matrix((ncolsx,ncolsx*(nrowsy-3-i)))
      coeff_row = sparse.hstack( [l2,l1,c0,r1,r2,rightzeros] )
    
    elif i==nrowsy-1:
      leftzeros = sparse.dia_matrix((ncolsx,ncolsx*(i-2)))
      coeff_row = sparse.hstack( [leftzeros,l2,l1,c0] )
    
    elif i==nrowsy-2:
      leftzeros = sparse.dia_matrix((ncolsx,ncolsx*(i-2)))
      coeff_row = sparse.hstack( [leftzeros,l2,l1,c0,r1] )

    elif i==nrowsy-3:
      leftzeros = sparse.dia_matrix((ncolsx,ncolsx*(i-2)))
      coeff_row = sparse.hstack( [leftzeros,l2,l1,c0,r1,r2] )

    # Concatenate these together
    # Looping over rows, so adding each set of values onto the bottom
    # of the previous set
    if i: # Can't concatenate the first time through loop when you only have one row
      c = sparse.vstack( [c,coeff_row] )
    elif ~i: # Create the array when you have only one row i=0
      c = coeff_row
  
  return c
  
    

def coeff_matrix_2d_serial(D,D_subset,drho,dx4,dy4,dx2dy2,nu=0.25,g=9.8):
  """
  coeff = coeff_matrix_2d(D=D,D_subset,nu=0.25,drho=drho,g=9.8,dx4=dx4,dy4=dy4,dx2dy2=dx2dy2)

  DEPRECATED: use coeff_matrix_2d; it is much faster and otherwise uses the
  exact same solution method.
  This function remains here as a historical record.

  Calculates the matrix of coefficients that is later used via a Thomas algorithm to compute
  the flexural response to the load. This step need only be performed once, and the coefficient
  matrix can very rapidly compute flexural solutions to any load. This makes this particularly
  good for probelms with time-variable loads or that require iteration (e.g., water loading, in
  which additional water causes subsidence, causes additional water detph, etc.).
  """

  from numpy import array, prod
  from scipy.sparse import lil_matrix
  
  coeff = lil_matrix((prod(D_subset.shape),prod(D_subset.shape)))
  
  row = 0
  
  c = lil_matrix(D.shape) # Define it here as well for matrix size calc.
  endlength = prod(c[2:-2,2:-2].shape) # Reshaped matrix size
  
  for i in range(2,D.shape[1]-2):
    for j in range(2,D.shape[0]-2):

      # Should add some rapid matrix creator in here for the case in which all or most
      # of the D's are the same, esp. to speed up benchmarking against analytical
      # solutions, which necessarily have constant D.
      
      c = lil_matrix(D.shape) # Coefficient matrix before reshaping into single row

      c[j+2,i] = (D[j,i] + 0.5*(D[j+1,i]-D[j-1,i])) / dy4
      c[j+1,i-1] = (2*D[j,i] \
          + 0.5*(-D[j,i+1]+D[j,i-1]+D[j+1,i]-D[j-1,i]) \
          + ((1-nu)/8)*(D[j+1,i+1]-D[j-1,i+1]-D[j+1,i-1]+D[j-1,i-1])) \
          / dx2dy2
      c[j+1,i] = (-6*D[j,i]+2*D[j-1,i])/dy4 \
          + nu*(D[j,i+1]-2*D[j,i]+D[j,i-1])/dx2dy2 \
          + (-D[j+1,i]-4*D[j,i]+D[j-1,i])/dx2dy2
      c[j+1,i+1] = (2*D[j,i] \
          + 0.5*(D[j,i+1]-D[j,i-1]+D[j+1,i]-D[j-1,i]) \
          + ((1-nu)/8)*(D[j+1,i+1]-D[j-1,i+1]-D[j+1,i-1]+D[j-1,i-1])) \
          / dx2dy2
      c[j,i-2] = (D[j,i] - 0.5*(D[j,i+1]-D[j,i-1])) / dx4
      c[j,i-1] = (2*D[j,i+1]-6*D[j,i])/dx4 \
          + nu*(D[j+1,i]-2*D[j,i]+D[j-1,i])/dx2dy2 \
          + (D[j,i+1]-4*D[j,i]-D[j,i-1])/dx2dy2
      c[j,i] = (-2*D[j,i+1]+10*D[j,i]-2*D[j,i-1])/dx4 \
          + (-2*D[j+1,i]+10*D[j,i]-2*D[j-1,i])/dy4 \
          + (8*D[j,i])/dx2dy2 \
          + nu*(-2*D[j,i+1]-2*D[j,i-1]+8*D[j,i]-2*D[j+1,i]-2*D[j-1,i])/dx2dy2 \
          + drho*g
      c[j,i+1] = (-6*D[j,i]+2*D[j,i-1])/dx4 \
          + nu*(D[j+1,i]-2*D[j,i]+D[j-1,i])/dx2dy2 \
          + (-D[j,i+1]-4*D[j,i]+D[j,i-1])/dx2dy2
      c[j,i+2] = (D[j,i] + 0.5*(D[j,i+1]-D[j,i-1])) / dx4
      c[j-1,i-1] = (2*D[j,i] \
          + 0.5*(-D[j,i+1]+D[j,i-1]-D[j+1,i]+D[j-1,i]) \
          + ((1-nu)/8)*(D[j+1,i+1]-D[j-1,i+1]-D[j+1,i-1]+D[j-1,i-1])) \
          / dx2dy2
      c[j-1,i] = (2*D[j+1,i]-6*D[j,i])/dy4 \
          + nu*(D[j,i+1]-2*D[j,i]+D[j,i-1])/dx2dy2 \
          + (D[j+1,i]-4*D[j,i]-D[j-1,i])/dx2dy2
      c[j-1,i+1] = (2*D[j,i] \
          + 0.5*(D[j,i+1]-D[j,i-1]-D[j+1,i]+D[j-1,i]) \
          - ((1-nu)/8)*(D[j+1,i+1]-D[j-1,i+1]-D[j+1,i-1]+D[j-1,i-1])) \
          / dx2dy2
      c[j-2,i] = (D[j,i] - 0.5*(D[j+1,i]-D[j-1,i])) / dy4
      
      #ccol = (c[2:-2,2:-2],endlength)
      # This conversion is REALLY inefficient; how to reshape sparse matrices?
      ccol = c.todense()
      # ccol = reshape
      ccol = ccol[2:-2,2:-2].reshape(1,endlength)
      coeff[row,:] = lil_matrix(ccol)
      
      row += 1 # Increment
      
  return coeff
  
def coeff_matrix_1D(D,drho,dx4,nu=0.25,g=9.8):
  """
  coeff = coeff_matrix_1D(D,nu,drho,g,dx4)
    where D is the flexural rigidity, nu is Poisson's ratio, drho is the density 
    difference between the mantle and the material filling the depression,
    g is gravitational acceleration at Earth's surface (approx. 9.8 m/s),
    and dx4 is based on the distance between grid cells (dx).
    
    All grid parameters except nu and g are generated by the function
    varprep2d, located inside this module
    
    D must be one cell larger than q0, the load array.
  
  1D pentadiagonal matrix to solve 1D flexure with variable elastic thickness
  via a Thomas algorithm (assuming that scipy uses a Thomas algorithm).
  
  Uses the thin plate assumption, as do all of the methods here.
  
  Based on and translated in part from "flexvar.m", written in 2001 by Bob
  Anderson, which in turn is based on a code written by Laura Wallace
  
  Changes here include increased vectorization of operations (for speed) and
  the use of sparse matrices (to reduce memory usage and unnecessary tracking
  of zeros)
  """
  
  from numpy import vstack, array
  from scipy.sparse import dia_matrix

  # Diagonals, from left to right  
  l2 = D[:-2] / dx4
  l1 = -2 * (D[1:-1] + D[:-2]) / dx4
  c0 = ( (D[2:] + 4*D[1:-1] + D[:-2]) / dx4 ) + drho*g
  r1 = -2 * (D[1:-1] + D[2:]) / dx4
  r2 = D[2:] / dx4
  
  # Construct sparse array
  ncolsx = c0.shape[0]
  coeffs = vstack((l2,l1,c0,r1,r2))
  offsets = array([-2,-1,0,1,2])
  c = dia_matrix( (coeffs,offsets), shape = (ncolsx,ncolsx) )

  return c
  
  
def direct_fd_solve_2d(coeff,q0,serial=0):
  """
  w = flex_calc(coeff,q0) \\
  \\
  Sparse Thomas algorithm-based flexural response calculation.
  Requires the coefficient matrix from "coeff_matrix_2d"
  """
  from scipy.sparse.linalg import spsolve
  from scipy.sparse import lil_matrix
  from numpy import prod
  if serial==1:
    q0t = q0.transpose() # Need to do this to make the "reshape" commands
                         # work correctly when using the serial method
                         # of coefficient matrix construction
    q0vector = q0t.reshape(1,prod(q0.shape))
  else:
    q0vector = q0.reshape(1,prod(q0.shape))
  q0vector = lil_matrix(q0vector)
  wvector = spsolve(coeff,q0vector)
  w = -wvector.reshape(q0.shape)

  return w

def direct_fd_solve_1d(coeff,q0):
  """
  w = direct_fd_solve_1d(coeff,q0)
    where coeff is the sparse coefficient matrix output from function
    coeff_matrix_2d and q0 is the array of loads

  Sparse solver for one-dimensional flexure of an elastic plate
  """
  
  from scipy.sparse.linalg import spsolve
  from scipy.sparse import lil_matrix

  q0sparse = lil_matrix(-q0) # Negative so bending down with positive load,
                             # bending up with negative load (i.e. material
                             # removed)
  w = spsolve(coeff,q0sparse)

  return w


def adi():
  """
  Alternating direction implicit: not written yet
  """
  
def fft_1D():
  """
  1D fast Fourier transform: not written yet
  """

def fft_2D():
  """
  2D fast Fourier transform: not written yet
  """
  
def analytical_1D():
  """
  T&S solution, necessarily constant D
  Sum line loads
  """
  
def analytical_2D():
  """
  Kelvin-Bessel fcn. solution; necessarily constant D
  Sum point loads
  """

def savesparse(filename,varname):
  """
  savesparse(filename,varname) \\
  \\
  "filename" must be a string with a ".mtx" extension. \\
  Will save file as a Matrix Market file. \\
  Good ASCII I/O option for the sparse matrix.
  """
  from scipy.io import mmwrite
  mmwrite(filename,varname)
  
def saveascii(filename,varname):
  """
  saveascii(filename,varname) \\
  \\
  "filename" must be a string and requires an extension (e.g., ".txt") \\
  Will save file as a space-delimited ASCII text file. \\
  Good for easy universal readability of arrays that should be small (e.g., the \\
  output flexural response).
  """
  from numpy import savetxt
  savetxt(fname=filename,X=varname,delimiter=' ')

def implot(a,x_label='',y_label='',fig_title=''):
  """
  implot(a,x_label,y_label,fig_title)
  
  Plots an image-stype figure with automatically generates axis labels and titles,
  colorbars, and properly-scaled dimensions.
  
  "a" is the input array
  """
  
  from matplotlib.pylab import imshow, colorbar, figure, axis, xlabel, ylabel, title
  figure(1)
  imshow(a)
  colorbar()
  axis('image')
  xlabel(x_label)
  ylabel(y_label)
  title(fig_title)

def lineplot(a,dx,x_label='',y_label='',fig_title=''):
  """
  lineplot(a,x_label='',y_label='',fig_title='')
  
  Plots a 2-D profile with axes and titles
  
  "a" is the vector to be plotted, and "dx" is the distance between elements
  in a.
  """
  
  from numpy import arange
  from matplotlib.pyplot import plot, figure, xlabel, ylabel, title, show
  
  x = dx*arange(a.shape[0])
  
  figure(1)
  plot(x,a)
  
  xlabel(x_label)
  ylabel(y_label)
  title(fig_title)
  
  show()
  

def implotall(Te,w,q0,x_label='',y_label='',q0_title='Load [kg/m$^2$ = Pa]',w_title='Flexure [m]',Te_title='Elastic thickness [km]'):
  """
  implotall(Te,w,q0,x_label,y_label,q0_title,w_title,Te_title)
  
  Plots figures for Te, w, and q0. Automatically generates axis labels, titles, \\
  and colorbars, and causes the plots to have properly-scaled dimensions. \\
  Of course, you don't have to make these figures be of Te, w, and q0... but this \\
  is what the variable names will say that they are.
  """
  from matplotlib.pylab import imshow, colorbar, figure, axis, xlabel, ylabel, title, show
  figure(1)
  imshow(Te/1000)
  colorbar()
  axis('image')
  xlabel(x_label)
  ylabel(y_label)
  title(Te_title)
  figure(2)
  imshow(w)
  colorbar()
  axis('image')
  xlabel(x_label)
  ylabel(y_label)
  title(w_title)
  figure(3)
  imshow(q0)
  colorbar()
  axis('image')
  xlabel(x_label)
  ylabel(y_label)
  title(q0_title)
  show()
  
  
#def varprep1d(dx,Te=Te,E=1E11,nu=0.25,rho_m=3300,rho_fill=0):
#  dx4 = dx**4
  
  
#def pad2d_const_value(a):
#  """
#  apad = pad2d_cost_value(a)
#  """
#  from numpy import nan
#  from numpy import array
#  apad = array([[nan,nan,a[0,:],nan,nan],[nan,a[0,0],a[0,:],a[0,-1],nan], \
#  [a[:,0],a[:,0],a,a[:,-1],a[:,-1]],[nan,a[-1,0],a[-1,:],a[-1,-1],nan], \
#  [nan,nan,a[-1,:],nan,nan]])
#  return apad
  
#def pad2d_const_gradient(a):
  
#def pad1d_const_value(a):

#def pad2d_const_gradient(a):

