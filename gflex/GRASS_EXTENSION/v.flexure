#! /usr/bin/python
############################################################################
#
# MODULE:       v.flexure
#
# AUTHOR(S):    Andrew Wickert
#
# PURPOSE:      Calculate flexure of the lithosphere under a specified
#               set of loads and with a given elastic thickness (scalar)
#
# COPYRIGHT:    (c) 2014 Andrew Wickert
#
#               This program is free software under the GNU General Public
#               License (>=v2). Read the file COPYING that comes with GRASS
#               for details.
#
#############################################################################
#
# REQUIREMENTS:
#      -  gFlex: http://csdms.colorado.edu/wiki/gFlex
#         (should be downloaded automatically along with the module)
#         github repository: https://github.com/awickert/gFlex
 
# More information
# Started 20 Jan 2015 to add GRASS GIS support for distributed point loads
# and their effects on lithospheric flexure

#%module
#%  description: Lithospheric flexure
#% keywords: vector
#%end
#%option
#%  key: q0
#%  type: string
#%  gisprompt: old,vector,vector
#%  description: Vector map of loads (thickness * area * density * g) [N]
#%  required : yes
#%end
#%option
#%  key: column
#%  type: string
#%  description: Column containing load values [N]
#%  required : yes
#%end
#%option
#%  key: te
#%  type: double
#%  description: Elastic thicnkess: scalar; unis chosen in "te_units"
#%  required : yes
#%end
#%option
#%  key: te_units
#%  type: string
#%  description: Units for elastic thickness
#%  options: m, km
#%  required : yes
#%end
#%option
#%  key: w
#%  type: string
#%  gisprompt: old,cell,raster
#%  description: Output raster map of vertical deflections [m]
#%  required : yes
#%end
#%option
#%  key: g
#%  type: double
#%  description: gravitational acceleration at surface [m/s^2]
#%  answer: 9.8
#%  required : no
#%end
#%option
#%  key: ym
#%  type: double
#%  description: Young's Modulus [Pa]
#%  answer: 65E9
#%  required : no
#%end
#%option
#%  key: nu
#%  type: double
#%  description: Poisson's ratio
#%  answer: 0.25
#%  required : no
#%end
#%option
#%  key: rho_fill
#%  type: double
#%  description: Density of material that fills flexural depressions [kg/m^3]
#%  answer: 0
#%  required : no
#%end
#%option
#%  key: rho_m
#%  type: double
#%  description: Mantle density [kg/m^3]
#%  answer: 3300
#%  required : no
#%end


# PATH
import sys

# GFLEX
import gflex

# PYTHON
import numpy as np
import time

# GRASS
import grass.script as grass
from grass.pygrass import vector

def main():

  # This code is for 2D flexural isostasy
  flex = gflex.F2D()
  # And show that it is coming from GRASS GIS
  flex.grass = True
  
  # Method
  flex.Method = 'SAS_NG'

  # Parameters that are often changed for the solution
  # x, y, q
  # for x,y see my StackOverflow answer:
  # http://gis.stackexchange.com/questions/28061/how-to-access-vector-coordinates-in-grass-gis-from-python
  points = vector.VectorTopo(options['q0'])
  points.open('r')
  coords = []
  for i in range(len(data)):
    coords.append(data.read(i+1).coords())
  coords = np.array(coords)
  flex.x = coords[:,0]
  flex.y = coords[:,1]
  # q
  vect_db = grass.vector_db_select(options['q0'])
  col_names = np.array(vect_db['columns'])
  q_col = (col_names == options['column'])
  if np.sum(q_col):
    col_values = np.array(vect_db['values'].values()).astype(float)
    flex.q = col_values[:, q_col]
  else:
    grass.fatal(_("provided column name, "+options['column']+" does not match\nany column in "+options['q0']+"."))    
  # Elastic thickness
  flex.Te = float(options['te'])
  if options['te_units'] == 'km':
    flex.Te *= 1000
  elif options['te_units'] == 'm':
    pass
  else:
      grass.fatal(_("Inappropriate te_units. How?"))
  flex.rho_fill = float(options['rho_fill'])
  # Parameters that often stay at their default values
  flex.g = float(options['g'])
  flex.E = float(options['ym']) # Can't just use "E" because reserved for "east", I think
  flex.nu = float(options['nu'])
  flex.rho_m = float(options['rho_m'])

  # Set verbosity
  if grass.verbosity() >= 2:
    flex.Verbose = True
  if grass.verbosity() >= 3:
    flex.Debug = True
  elif grass.verbosity() == 0:
    flex.Quiet = True
  
  # First check if output exists
  if len(grass.parse_command('g.list', type='rast', pattern=options['output'])):
    if not grass.overwrite():
      grass.fatal(_("Raster map '" + output + "' already exists. Use '--o' to overwrite."))
  
  # Check if lat/lon and let user know if verbosity is True
  if grass.region_env()[6] == '3':
    if flex.Verbose:
      print "Latitude/longitude grid."
      print "Based on r_Earth = 6371 km"
      print "Computing distances between load points using great circle paths"

  # CALCULATE!
  flex.initialize()
  flex.run()
  flex.finalize()

  # Write to GRASS
  # Create a new garray buffer and write to it
  outbuffer = garray.array() # Instantiate output buffer
  outbuffer[...] = flex.w
  outbuffer.write(options['output'], overwrite=grass.overwrite) # Write it with the desired name
  # And create a nice colormap!
  grass.run_command('r.colors', map=options['output'], color='differences', quiet=True)

  # Reinstate this with a flag or output filename
  # But I think better to let interpolation happen a posteriori
  # So the user knows what the solution is and what it isn't
  #grass.run_command('r.resamp.interp', input=output, output=output + '_interp', method='lanczos', overwrite=True, quiet=True)
  #grass.run_command('r.colors', map=output + '_interp', color='rainbow', quiet=True)#, flags='e')

if __name__ == "__main__":
  options, flags = grass.parser()
  #original_sigint = signal.getsignal(signal.SIGINT)
  #signal.signal(signal.SIGINT, exit_gracefully)
  try:
    main()
  except:
    sys.exit()

