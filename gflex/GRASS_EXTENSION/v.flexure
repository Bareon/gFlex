#! /usr/bin/python
############################################################################
#
# MODULE:       v.flexure
#
# AUTHOR(S):    Andrew Wickert
#
# PURPOSE:      Calculate flexure of the lithosphere under a specified
#               set of loads and with a given elastic thickness (scalar)
#
# COPYRIGHT:    (c) 2014 Andrew Wickert
#
#               This program is free software under the GNU General Public
#               License (>=v2). Read the file COPYING that comes with GRASS
#               for details.
#
#############################################################################
#
# REQUIREMENTS:
#      -  gFlex: http://csdms.colorado.edu/wiki/gFlex
#         (should be downloaded automatically along with the module)
#         github repository: https://github.com/awickert/gFlex
 
# More information
# Started 20 Jan 2015 to add GRASS GIS support for distributed point loads
# and their effects on lithospheric flexure

#%module
#%  description: Lithospheric flexure
#% keywords: vector
#%end
#%flag
#%  key: l
#%  description: Allows running in lat/lon: distances from great circles
#%end
#%flag
#%  key: r
#%  description: Use user-specified resolution (otherwise internally computed)
#%end
#%option
#%  key: q
#%  type: string
#%  gisprompt: old,vector,vector
#%  description: Vector map of loads (thickness * area * density * g) [N]
#%  required : yes
#%end
#%option
#%  key: te
#%  type: string
#%  description: Elastic thicnkess: scalar; unis chosen in "te_units"
#%  required : yes
#%end
#%option
#%  key: te_units
#%  type: string
#%  description: Units for elastic thickness
#%  options: m, km
#%  required : yes
#%end
#%option
#%  key: output
#%  type: string
#%  gisprompt: old,cell,raster
#%  description: Output raster map of vertical deflections [m]
#%  required : yes
#%end
#%option
#%  key: g
#%  type: double
#%  description: gravitational acceleration at surface [m/s^2]
#%  answer: 9.8
#%  required : no
#%end
#%option
#%  key: ym
#%  type: double
#%  description: Young's Modulus [Pa]
#%  answer: 65E10
#%  required : no
#%end
#%option
#%  key: nu
#%  type: double
#%  description: Poisson's ratio
#%  answer: 0.25
#%  required : no
#%end
#%option
#%  key: rho_fill
#%  type: double
#%  description: Density of material that fills flexural depressions [kg/m^3]
#%  answer: 0
#%  required : no
#%end
#%option
#%  key: rho_m
#%  type: double
#%  description: Mantle density [kg/m^3]
#%  answer: 3300
#%  required : no
#%end


# PATH
import sys

# GFLEX
import gflex

# PYTHON
import numpy as np
import time

# GRASS
from grass.script import core as grass
from grass.script import mapcalc
from grass.script import db as db
import grass.script.array as garray

def main():

  # Flags
  latlon_override = flags['l']
  user_resolution_override = flags['r']
  
  # Inputs
  # Solution selection
  method = options['method']
  # Parameters that are often changed for the solution
  q0 = options['q0']
  Te = options['te']
  Te_units = options['te_units']
  rho_fill = float(options['rho_fill'])
  # Parameters that often stay at their default values
  GravAccel = float(options['g'])
  YoungsModulus = float(options['ym']) # Can't just use "E" because reserved for "east", I think
  PoissonsRatio = float(options['nu'])
  MantleDensity = float(options['rho_m'])
  # Solver type and iteration tolerance
  Solver = options['solver']
  ConvergenceTolerance = float(options['tolerance'])
  # Boundary conditions
  bcn = options['northbc']
  bcs = options['southbc']
  bcw = options['westbc']
  bce = options['eastbc']
  # Output
  output = options['output']
  
  # Is Te raster or scalar?
  TeIsRast = False
  try:
    Te = float(Te)
  except:
    TeIsRast = True

  # This code is for 2D flexural isostasy
  obj = gflex.F2D()
  # And it is for the nongridded superposition of analytical solutions
  obj.set_value('Method', 'SAS_NG')
   
  # Set verbosity
  if grass.verbosity() >= 2:
    obj.set_value('Verbose', True)
  if grass.verbosity() >= 3:
    obj.set_value('Debug', True)
  elif grass.verbosity() == 0:
    obj.set_value('Quiet', True)
  
  # Make a bunch of standard selections
  obj.set_value('GravAccel', GravAccel)
  obj.set_value('YoungsModulus', YoungsModulus)
  obj.set_value('PoissonsRatio', PoissonsRatio)
  obj.set_value('MantleDensity', MantleDensity)
  
  # IF RASTER OUTPUT -- HAVE VECTOR OUTPUT OPTION AVAILABLE TOO
  # WAIT, RASTER OUTPUT NOT POSSIBLE IN MY CODE!
  # WELL, IS VERY EASY TO CODE
  # But will have to update plotting steps with regular grid, add an option 
  # to have grid outputs, have new xout, yout for the grid, ...but should
  # be possible.
  # THEN to assign a solution grid
  
  # Create region
  
  # Create grid in that region
  # Resolution either imposed or automatically calculated based on 
  # flexural wavelength
  
  # Convert that grid to vector points array

  # Find a way to pass the lat/lon converted distancces into the formula -- 
  # -- perhaps by including a lat/lon input possiblity -- in fact, may have to 
  # calculate it over there because of the structure of the code
  
  """
  # To help start:
  # From 
  # 
  def distance_on_unit_sphere(lat1, long1, lat2, long2):
   
      # Convert latitude and longitude to
      # spherical coordinates in radians.
      degrees_to_radians = math.pi/180.0
           
      # phi = 90 - latitude
      phi1 = (90.0 - lat1)*degrees_to_radians
      phi2 = (90.0 - lat2)*degrees_to_radians
           
      # theta = longitude
      theta1 = long1*degrees_to_radians
      theta2 = long2*degrees_to_radians
           
      # Compute spherical distance from spherical coordinates.
           
      # For two locations in spherical coordinates
      # (1, theta, phi) and (1, theta, phi)
      # cosine( arc length ) =
      #    sin phi sin phi' cos(theta-theta') + cos phi cos phi'
      # distance = rho * arc length
       
      cos = (math.sin(phi1)*math.sin(phi2)*math.cos(theta1 - theta2) +
             math.cos(phi1)*math.cos(phi2))
      arc = math.acos( cos )
   
      # Remember to multiply arc by the radius of the earth
      # in your favorite set of units to get length.
      return arc
  """
  
  #   
  
  # 
  
  
  
  # Next steps will be to 


  # Get grid spacing from GRASS
  # Check if lat/lon
  if grass.region_env()[6] == '3':
    if latlon_override:
      if obj.get_value('Verbosity'):
        print "Latitude/longitude grid."
        print "Based on r_Earth = 6371 km"
        print "Setting y-resolution [m] to 111,195 * [degrees]"
      obj.set_value('GridSpacing_x', grass.region()['ewres']*111195.)
      NSmid = (grass.region()['n'] + grass.region()['s'])/2.
      dx_at_mid_latitude = (3.14159/180.) * 6371000. * np.cos(np.deg2rad(NSmid))
      if obj.get_value('Verbosity'):
        print "Setting x-resolution [m] to "+"%.2f" %dx_at_mid_latitude+" * [degrees]"
      obj.set_value('GridSpacing_y', grass.region()['nsres']*dx_at_mid_latitude)
    else:
      sys.exit("Need projected coordinates, or the '-l' flag to approximate.")
  else:
    obj.set_value('GridSpacing_x', grass.region()['ewres'])
    obj.set_value('GridSpacing_y', grass.region()['nsres'])

  # Get loads from GRASS
  # Calling it "qs" because these are stresses and q0 is the path to the input
  # (so similar to usage in main code)
  # Not deleting q0 because we need to keep the array name to re-set the region 
  # at the end
  qsrast = garray.array()
  qsrast.read(q0)
  
  # Get elastic thickness from GRASS if it is not a scalar value
  if TeIsRast:
    FlexureTe = garray.array() # FlexureTe is the one that is used by Flexure
    FlexureTe.read(Te)
  else:
    FlexureTe = Te
    
  # Adjust elastic thickness if given in km
  if Te_units == 'km':
    FlexureTe *= 1000 # for km --> m
    # meters are the only other option, so just do nothing otherwise

  # Values set by user -- set to np.array for flow control in main code
  obj.set_value('Loads', np.array(qsrast))
  if type(FlexureTe) == type(garray.array()):
    obj.set_value('ElasticThickness', np.array(FlexureTe))
  else:
    # if scalar
    obj.set_value('ElasticThickness', FlexureTe)
  obj.set_value('InfillMaterialDensity', rho_fill)

  # CALCULATE!
  obj.initialize()
  obj.run()
  obj.finalize()


  # Write to GRASS
  # Create a new garray buffer and write to it
  outbuffer = garray.array() # Instantiate output buffer
  outbuffer[...] = obj.w
  outbuffer.write(output, overwrite=True) # Write it with the desired name
  # And create a nice colormap!
  grass.run_command('r.colors', map=output, color='differences', quiet=True)

  # Finally, return to original resolution (overwrites previous region selection)
  grass.run_command('g.region', rast=q0)
  
  # Reinstate this with a flag or output filename
  #grass.run_command('r.resamp.interp', input=output, output=output + '_interp', method='lanczos', overwrite=True, quiet=True)
  #grass.run_command('r.colors', map=output + '_interp', color='rainbow', quiet=True)#, flags='e')

  #imshow(obj.w, interpolation='nearest'), show()

if __name__ == "__main__":
  options, flags = grass.parser()
  main()

