#! /usr/bin/python
############################################################################
#
# MODULE:       r.flexure
#
# AUTHOR(S):    Andrew Wickert
#
# PURPOSE:      Calculate flexure of the lithosphere under a specified
#               set of loads and with a given elastic thickness (scalar 
#               or array)
#
# COPYRIGHT:    (c) 2012, 2014 Andrew Wickert
#
#               This program is free software under the GNU General Public
#               License (>=v2). Read the file COPYING that comes with GRASS
#               for details.
#
#############################################################################
#
# REQUIREMENTS:
#      -  gFlex: http://csdms.colorado.edu/wiki/gFlex
#         (should be downloaded automatically along with the module)
#         github repository: https://github.com/awickert/gFlex
 
# More information
# Started 11 March 2012 as a GRASS interface for Flexure (now gFlex)
# Revised 15--?? November 2014 after significantly improving the model
# by Andy Wickert

#%module
#%  description: Lithospheric flexure
#% keywords: raster
#%end
#%flag
#%  key: l
#%  description: Allows running in lat/lon: dx is f(lat) at grid N-S midpoint
#%end
#%option
#%  key: method
#%  type: string
#%  description: Solution method: Finite Diff. or Superpos. of analytical sol'ns
#%  options: FD, SAS
#%  required : yes
#%end
#%option
#%  key: q0
#%  type: string
#%  gisprompt: old,cell,raster
#%  description: Raster map of loads (thickness * density * g) [Pa]
#%  required : yes
#%end
#%option
#%  key: te
#%  type: string
#%  gisprompt: old,cell,raster
#%  description: Elastic thicnkess: scalar or raster; unis chosen in "te_units"
#%  required : yes
#%end
#%option
#%  key: te_units
#%  type: string
#%  description: Units for elastic thickness
#%  options: m, km
#%  required : yes
#%end
#%option
#%  key: output
#%  type: string
#%  gisprompt: old,cell,raster
#%  description: Output raster map of vertical deflections [m]
#%  required : yes
#%end
#%option
#%  key: solver
#%  type: string
#%  description: Solver type
#%  options: direct, iterative
#%  answer: direct
#%  required : no
#%end
#%option
#%  key: tolerance
#%  type: double
#%  description: Convergence tolerance (between iterations) for iterative solver
#%  answer: 1E-3
#%  required : no
#%end
#%option
#%  key: northbc
#%  type: string
#%  description: Northern boundary condition
#%  options: Dirichlet0, 0Moment0Shear, 0Slope0Shear, Mirror, Periodic, NoOutsideLoads
#%  answer: NoOutsideLoads
#%  required : no
#%end
#%option
#%  key: southbc
#%  type: string
#%  description: Southern boundary condition
#%  options: Dirichlet0, 0Moment0Shear, 0Slope0Shear, Mirror, Periodic, NoOutsideLoads
#%  answer: NoOutsideLoads
#%  required : no
#%end
#%option
#%  key: westbc
#%  type: string
#%  description: Western boundary condition
#%  options: Dirichlet0, 0Moment0Shear, 0Slope0Shear, Mirror, Periodic, NoOutsideLoads
#%  answer: NoOutsideLoads
#%  required : no
#%end
#%option
#%  key: eastbc
#%  type: string
#%  description: Eastern boundary condition
#%  options: Dirichlet0, 0Moment0Shear, 0Slope0Shear, Mirror, Periodic, NoOutsideLoads
#%  answer: NoOutsideLoads
#%  required : no
#%end
#%option
#%  key: g
#%  type: double
#%  description: gravitational acceleration at surface [m/s^2]
#%  answer: 9.8
#%  required : no
#%end
#%option
#%  key: ym
#%  type: double
#%  description: Young's Modulus [Pa]
#%  answer: 65E9
#%  required : no
#%end
#%option
#%  key: nu
#%  type: double
#%  description: Poisson's ratio
#%  answer: 0.25
#%  required : no
#%end
#%option
#%  key: rho_fill
#%  type: double
#%  description: Density of material that fills flexural depressions [kg/m^3]
#%  answer: 0
#%  required : no
#%end
#%option
#%  key: rho_m
#%  type: double
#%  description: Mantle density [kg/m^3]
#%  answer: 3300
#%  required : no
#%end


# GFLEX
import gflex

# PYTHON
import numpy as np
import sys

# GRASS
from grass.script import core as grass
import grass.script.array as garray

def main():

  # This code is for 2D flexural isostasy
  obj = gflex.F2D()
  # And show that it is coming from GRASS GIS
  obj.grass = True
  
  # Flags
  latlon_override = flags['l']
  
  # Inputs
  # Solution selection
  obj.Method = options['method']
  if obj.Method == 'FD':
    obj.Solver = options['solver']
    if obj.Solver:
      obj.ConvergenceTolerance = options['tolerance']
    # Always use the van Wees and Cloetingh (1994) solution type.
    # It is the best.
    obj.PlateSolutionType = 'vWC1994'
  # Parameters that are often changed for the solution
  qs = options['q0']
  obj.qs = garray.array()
  obj.qs.read(qs)
  # Elastic thickness
  try:
    obj.Te = float(options['te'])
  except:
    obj.Te = garray.array() # FlexureTe is the one that is used by Flexure
    obj.Te.read(options['te'])
    obj.Te = np.array(obj.Te)
  if options['te_units'] == 'km':
    obj.Te *= 1000
  elif options['te_units'] == 'm':
    pass
  else:
    sys.exit() # Just do this in case there is a mistake in the options
               # limitations given above
  obj.rho_fill = float(options['rho_fill'])
  # Parameters that often stay at their default values
  obj.g = float(options['g'])
  obj.E = float(options['ym']) # Can't just use "E" because reserved for "east", I think
  obj.nu = float(options['nu'])
  obj.rho_m = float(options['rho_m'])
  # Solver type and iteration tolerance
  obj.Solver = options['solver']
  obj.ConvergenceTolerance = float(options['tolerance'])
  # Boundary conditions
  obj.BC_N = options['northbc']
  obj.BC_S = options['southbc']
  obj.BC_W = options['westbc']
  obj.BC_E = options['eastbc']
  # Set verbosity
  if grass.verbosity() >= 2:
    obj.Verbose = True
  if grass.verbosity() >= 3:
    obj.Debug = True
  elif grass.verbosity() == 0:
    obj.Quiet = True
  
  # First check if output exists
  if len(grass.parse_command('g.list', type='rast', pattern=options['output'])):
    if not grass.overwrite():
      grass.fatal(_("Raster map '" + output + "' already exists. Use '--o' to overwrite."))
  
  # Get grid spacing from GRASS
  # Check if lat/lon and proceed as directed
  if grass.region_env()[6] == '3':
    if latlon_override:
      if obj.get_value('Verbosity'):
        print "Latitude/longitude grid."
        print "Based on r_Earth = 6371 km"
        print "Setting y-resolution [m] to 111,195 * [degrees]"
      obj.dy = grass.region()['nsres']*111195.
      NSmid = (grass.region()['n'] + grass.region()['s'])/2.
      dx_at_mid_latitude = (3.14159/180.) * 6371000. * np.cos(np.deg2rad(NSmid))
      if obj.Verbose:
        print "Setting x-resolution [m] to "+"%.2f" %dx_at_mid_latitude+" * [degrees]"
      obj.dx = grass.region()['ewres']*dx_at_mid_latitude
    else:
      grass.fatal(_("Need the '-l' flag to enable lat/lon solution approximation."))
  # Otherwise straightforward
  else:
    obj.dx = grass.region()['ewres']
    obj.dy = grass.region()['nsres']

  # CALCULATE!
  obj.initialize()
  obj.run()
  obj.finalize()

  # Write to GRASS
  # Create a new garray buffer and write to it
  outbuffer = garray.array() # Instantiate output buffer
  outbuffer[...] = obj.w
  outbuffer.write(options['output'], overwrite=grass.overwrite) # Write it with the desired name
  # And create a nice colormap!
  grass.run_command('r.colors', map=options['output'], color='differences', quiet=True)

  # Reinstate this with a flag or output filename
  # But I think better to let interpolation happen a posteriori
  # So the user knows what the solution is and what it isn't
  #grass.run_command('r.resamp.interp', input=output, output=output + '_interp', method='lanczos', overwrite=True, quiet=True)
  #grass.run_command('r.colors', map=output + '_interp', color='rainbow', quiet=True)#, flags='e')

if __name__ == "__main__":
  options, flags = grass.parser()
  main()

